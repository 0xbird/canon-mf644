
from bip import *
import idautils
import ida_bytes
import re

def get_ea_from_arg(cn, arg_num):
    """
        Try to get address of the object at argument ``arg_num`` of
        a :class:`CNodeExprCall` ``cn``. Return the address if successfull or
        ``None`` if unsuccessful.
    """
    cn = cn.ignore_cast
    try:
        o = cn.get_arg(arg_num).ignore_cast
    except ValueError:
        # this is in case arg_num is bigger than the number of args
        return None
    if not isinstance(o, CNodeExprObj):
        return None # error
    v = o.value
    #if v == 0 or v == idc.BADADDR: # invalid addr
    #    return None
    return v

def get_func_ref_ea(ea):
    """
        Get all function which reference object at ea.

        :return: A set of function
    """
    r = set()
    for instr in GetElt(ea).xCodeTo:
        try:
            r.add(instr.func)
        except Exception:
            continue
    return r

# TODO: add in bip util hexray plugin
def get_cn_call_to_func(f, func):
    """
        Return all CNodeExprCall in f which call func (directly)
    """
    res = []
    if isinstance(func, BipFunction) or isinstance(func, BipElt):
        fn = func.name
    else:
        fn = func
    try:
        hxf = f.hxcfunc
    except BipDecompileError: # IDA failed to decompiled
        return []
    for cn in hxf.get_cnode_filter_type(CNodeExprCall):
        caller = cn.caller.ignore_cast
        if not isinstance(caller, CNodeExprObj):
            continue # indirect call or something
        try:
            name = GetElt(caller.value).name
        except ValueError:
            continue # ignore this
        if name == fn:
            res.append(cn)
    return res

def get_all_cn_calling_func(func):
    """
        Return all CNodeExprCall in which func is directly called. Those CNode
        may not (and will probably not be) in the same function.
    """
    res = []
    if isinstance(func, str):
        func = BipFunction.get_by_name(func)
    elif isinstance(func, int):
        func = BipFunction(func)
    elif isinstance(func, BipElt):
        func = func.func
    #hxf = func.hxfunc
    for fu in func.callers:
        res += get_cn_call_to_func(fu, func)
    return res

def rename_from_strarg_unique(cncall, bip_function, str_value, stridx, argidx, prefix=""):
    """
        Rename function containing :class:`CNodeExprCall` ``cncall`` (not the
        one called by the cnode) if the argument at ``argidx`` is a string
        only reference by that function.

        This will not rename function which are already renamed

        :return: True if renaming was done, False otherwise.
    """
    if argidx >= cncall.number_args or stridx >= cncall.number_args:
        return False

    if not bip_function.is_ida_name: # not default name
        return False

    # get string '[RUI] %s...' specified in logf
    ea = get_ea_from_arg(cncall, stridx)
    if ea is None or ea == 0:
        return False
    cstring = BipData.get_cstring(ea)
    if cstring is None:
        return False
    s = str(cstring, 'utf-8')
    if s != str_value:
        return False

    # get function name specified in logf
    ea = get_ea_from_arg(cncall, argidx)
    if ea is None or ea == 0:
        return False
    cstring = BipData.get_cstring(ea)
    if cstring is None:
        return False
    s = str(cstring, 'utf-8')

    # avoid case where arg is a filepath or contains
    # a bad character
    if s.find('/') == -1 and s.find(' ') == -1:
        new_name = ('%s_%s_%x' % (prefix, s, bip_function.ea))
        try:
            print('Renaming %s to %s' % (bip_function.name, new_name))
            bip_function.name = new_name
        except Exception as e:
            print(e)
            return False
        return True

if __name__ == '__main__':

    sc = idautils.Strings()
    print('Strings list loaded...')

    prefixes = set()
    # e.g "[LUI] %s ERROR [Invalid Arg]\n", "cuwm_getHomeSelectIndex")
    prog=re.compile('\[[A-Za-z]{1,}\] %s.*')

    log_func = BipFunction.get_by_name('logf')
    # List of strings generated by idautils.Strings
    # (may not be identified as strings in the ida view)
    for s in sc:
        str_value = str(s)
        result_match = prog.match(str_value)
        if result_match is not None:
            matched_pattern = result_match.group()
            start, end = result_match.span()
            assert start == 0
            end_prefix = matched_pattern.find(']')
            assert end_prefix < end
            prefix = result_match.group()[1:end_prefix]

            print('Found string %s at %x' % (str_value, s.ea))
            if not isinstance(base.BipData(s.ea).type, base.biptype.BTypeArray):
                ida_bytes.create_strlit(s.ea, s.length, s.strtype)
            # x-ref to function manipulating our string
            allf = get_func_ref_ea(s.ea)
            for f in allf:
                # all call to functions calling log_func, and having at
                # least 1 x-ref on our string 
                for cn in get_cn_call_to_func(f, log_func):
                    rename_from_strarg_unique(cn, f, str_value, 2, 3, prefix=prefix)
